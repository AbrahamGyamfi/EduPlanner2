"""
Schedule export module for EduMaster application.
This module handles exporting schedules in various formats (PDF, JSON, CSV, iCal).
"""

import logging
import json
import csv
from datetime import datetime, timezone
from flask import request, jsonify, Response, make_response
from bson import ObjectId
from io import StringIO

from database import schedules_collection, users_collection
from utils import log_user_action
from pdf_generator import SchedulePDFGenerator
from notifications import notification_manager
from schedule_core import _calculate_schedule_statistics

logger = logging.getLogger(__name__)

def _generate_ical_content(schedule_data, user_name):
    """Generate iCal content from schedule data"""
    ical_lines = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//EduMaster//Schedule Export//EN",
        "CALSCALE:GREGORIAN",
        "METHOD:PUBLISH",
        f"X-WR-CALNAME:{schedule_data.get('schedule_name', 'EduMaster Schedule')}",
        "X-WR-CALDESC:Study schedule generated by EduMaster"
    ]
    
    schedule_sessions = schedule_data.get('schedule', [])
    
    for session in schedule_sessions:
        # Generate unique UID for each session
        session_id = session.get('id', f"session_{hash(str(session))}")
        
        # Parse time
        time_str = session.get('time', '')
        if '-' in time_str:
            try:
                start_time_str, end_time_str = time_str.split('-')
                start_hour, start_min = map(int, start_time_str.strip().split(':'))
                end_hour, end_min = map(int, end_time_str.strip().split(':'))
            except:
                start_hour, start_min = 9, 0  # Default 9:00 AM
                end_hour, end_min = 11, 0    # Default 11:00 AM
        else:
            start_hour, start_min = 9, 0
            end_hour, end_min = 11, 0
        
        # Map day to weekday number (Monday = 0)
        day_mapping = {
            'monday': 0, 'tuesday': 1, 'wednesday': 2, 'thursday': 3,
            'friday': 4, 'saturday': 5, 'sunday': 6
        }
        
        weekday = day_mapping.get(session.get('day', '').lower(), 0)
        
        # Create recurring event (weekly)
        from datetime import timedelta
        now = datetime.now()
        # Find next occurrence of the weekday
        days_ahead = weekday - now.weekday()
        if days_ahead <= 0:  # Target day already happened this week
            days_ahead += 7
        
        event_date = now.replace(hour=start_hour, minute=start_min, second=0, microsecond=0)
        event_date = event_date + timedelta(days=days_ahead)
        
        end_date = event_date.replace(hour=end_hour, minute=end_min)
        
        # Format datetime for iCal (UTC)
        dtstart = event_date.strftime('%Y%m%dT%H%M%S')
        dtend = end_date.strftime('%Y%m%dT%H%M%S')
        dtstamp = datetime.now().strftime('%Y%m%dT%H%M%SZ')
        
        # Add event
        ical_lines.extend([
            "BEGIN:VEVENT",
            f"UID:{session_id}@edumaster.com",
            f"DTSTART:{dtstart}",
            f"DTEND:{dtend}",
            f"DTSTAMP:{dtstamp}",
            f"SUMMARY:{session.get('subject', 'Study Session')}",
            f"DESCRIPTION:{session.get('notes', '')}",
            f"LOCATION:{session.get('location', '')}",
            "RRULE:FREQ=WEEKLY",
            "END:VEVENT"
        ])
    
    ical_lines.append("END:VCALENDAR")
    return "\n".join(ical_lines)

def _generate_csv_content(schedule_data):
    """Generate CSV content from schedule data"""
    output = StringIO()
    writer = csv.writer(output)
    
    # Write header
    writer.writerow(['Day', 'Time', 'Subject', 'Type', 'Location', 'Notes'])
    
    # Write schedule data
    schedule_sessions = schedule_data.get('schedule', [])
    for session in schedule_sessions:
        writer.writerow([
            session.get('day', ''),
            session.get('time', ''),
            session.get('subject', ''),
            session.get('type', ''),
            session.get('location', ''),
            session.get('notes', '')
        ])
    
    csv_content = output.getvalue()
    output.close()
    return csv_content

def register_schedule_export_routes(app):
    """Register schedule export routes with the Flask app"""
    
    @app.route('/schedule/<user_id>/export-json', methods=['GET'])
    def export_schedule_json(user_id):
        """Export user schedule as JSON"""
        try:
            # Validate user exists
            try:
                user_object_id = ObjectId(user_id) if isinstance(user_id, str) else user_id
                user = users_collection.find_one({"_id": user_object_id})
                if not user:
                    return jsonify({'error': 'User not found'}), 404
            except:
                return jsonify({'error': 'Invalid user ID format'}), 400
            
            # Get the user's schedule
            query = {'userId': {'$in': [user_id, user_object_id]}, 'is_active': True}
            schedule_doc = schedules_collection.find_one(query)
            
            if not schedule_doc:
                return jsonify({'error': 'No active schedule found for this user'}), 404
            
            # Prepare export data
            export_data = {
                'export_info': {
                    'exported_by': 'EduMaster',
                    'export_date': datetime.now().isoformat(),
                    'user_name': f"{user.get('firstname', '')} {user.get('lastname', '')}".strip(),
                    'user_email': user.get('email', ''),
                    'format_version': '1.0'
                },
                'schedule_data': {
                    'schedule_id': str(schedule_doc['_id']),
                    'schedule_name': schedule_doc.get('schedule_name', 'Default Schedule'),
                    'schedule': schedule_doc.get('schedule', []),
                    'preferences': schedule_doc.get('preferences', {}),
                    'is_active': schedule_doc.get('is_active', True),
                    'created_at': schedule_doc.get('created_at').isoformat() if schedule_doc.get('created_at') else None,
                    'updated_at': schedule_doc.get('updated_at').isoformat() if schedule_doc.get('updated_at') else None,
                    'statistics': _calculate_schedule_statistics(schedule_doc.get('schedule', []))
                }
            }
            
            # Create response
            json_content = json.dumps(export_data, indent=2, ensure_ascii=False)
            
            response = make_response(json_content)
            response.headers['Content-Type'] = 'application/json'
            response.headers['Content-Disposition'] = f'attachment; filename="schedule_{user_id}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json"'
            
            # Log the export
            log_user_action(user_id, "schedule_json_export", {
                "schedule_id": str(schedule_doc['_id']),
                "session_count": len(schedule_doc.get('schedule', []))
            })
            
            logger.info(f"Schedule JSON export completed for user {user_id}")
            return response
            
        except Exception as e:
            logger.error(f"Error exporting schedule as JSON: {str(e)}")
            return jsonify({'error': 'Error exporting schedule as JSON'}), 500

    @app.route('/schedule/<user_id>/export-csv', methods=['GET'])
    def export_schedule_csv(user_id):
        """Export user schedule as CSV"""
        try:
            # Validate user exists
            try:
                user_object_id = ObjectId(user_id) if isinstance(user_id, str) else user_id
                user = users_collection.find_one({"_id": user_object_id})
                if not user:
                    return jsonify({'error': 'User not found'}), 404
            except:
                return jsonify({'error': 'Invalid user ID format'}), 400
            
            # Get the user's schedule
            query = {'userId': {'$in': [user_id, user_object_id]}, 'is_active': True}
            schedule_doc = schedules_collection.find_one(query)
            
            if not schedule_doc:
                return jsonify({'error': 'No active schedule found for this user'}), 404
            
            # Generate CSV content
            csv_content = _generate_csv_content(schedule_doc)
            
            response = make_response(csv_content)
            response.headers['Content-Type'] = 'text/csv'
            response.headers['Content-Disposition'] = f'attachment; filename="schedule_{user_id}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv"'
            
            # Log the export
            log_user_action(user_id, "schedule_csv_export", {
                "schedule_id": str(schedule_doc['_id']),
                "session_count": len(schedule_doc.get('schedule', []))
            })
            
            logger.info(f"Schedule CSV export completed for user {user_id}")
            return response
            
        except Exception as e:
            logger.error(f"Error exporting schedule as CSV: {str(e)}")
            return jsonify({'error': 'Error exporting schedule as CSV'}), 500

    @app.route('/schedule/<user_id>/export-ical', methods=['GET'])
    def export_schedule_ical(user_id):
        """Export user schedule as iCal format"""
        try:
            # Validate user exists
            try:
                user_object_id = ObjectId(user_id) if isinstance(user_id, str) else user_id
                user = users_collection.find_one({"_id": user_object_id})
                if not user:
                    return jsonify({'error': 'User not found'}), 404
            except:
                return jsonify({'error': 'Invalid user ID format'}), 400
            
            # Get the user's schedule
            query = {'userId': {'$in': [user_id, user_object_id]}, 'is_active': True}
            schedule_doc = schedules_collection.find_one(query)
            
            if not schedule_doc:
                return jsonify({'error': 'No active schedule found for this user'}), 404
            
            # Generate iCal content
            user_name = f"{user.get('firstname', '')} {user.get('lastname', '')}".strip()
            ical_content = _generate_ical_content(schedule_doc, user_name)
            
            response = make_response(ical_content)
            response.headers['Content-Type'] = 'text/calendar'
            response.headers['Content-Disposition'] = f'attachment; filename="schedule_{user_id}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.ics"'
            
            # Log the export
            log_user_action(user_id, "schedule_ical_export", {
                "schedule_id": str(schedule_doc['_id']),
                "session_count": len(schedule_doc.get('schedule', []))
            })
            
            logger.info(f"Schedule iCal export completed for user {user_id}")
            return response
            
        except Exception as e:
            logger.error(f"Error exporting schedule as iCal: {str(e)}")
            return jsonify({'error': 'Error exporting schedule as iCal'}), 500

    @app.route('/schedule/<user_id>/export-pdf', methods=['POST'])
    def export_schedule_pdf(user_id):
        """Export user schedule as PDF and send via email"""
        try:
            # Get customization options from request
            data = request.json or {}
            send_email = data.get('send_email', True)
            include_statistics = data.get('include_statistics', True)
            color_theme = data.get('color_theme', 'default')  # default, blue, green, purple
            date_range = data.get('date_range')  # optional: {'start': 'YYYY-MM-DD', 'end': 'YYYY-MM-DD'}
            subjects_filter = data.get('subjects_filter', [])  # optional: list of subjects to include
            
            # Validate user exists and get user data
            try:
                user_object_id = ObjectId(user_id) if isinstance(user_id, str) else user_id
                user = users_collection.find_one({"_id": user_object_id})
                if not user:
                    return jsonify({'error': 'User not found'}), 404
            except:
                return jsonify({'error': 'Invalid user ID format'}), 400
            
            # Get the user's schedule
            query = {'userId': {'$in': [user_id, user_object_id]}, 'is_active': True}
            schedule_doc = schedules_collection.find_one(query)
            
            if not schedule_doc:
                return jsonify({'error': 'No active schedule found for this user'}), 404
            
            # Extract and filter schedule data
            schedule = schedule_doc.get('schedule', [])
            preferences = schedule_doc.get('preferences', {})
            schedule_name = schedule_doc.get('schedule_name', 'Default Schedule')
            
            # Apply subject filter if specified
            if subjects_filter:
                schedule = [session for session in schedule if session.get('subject') in subjects_filter]
            
            if not schedule:
                return jsonify({'error': 'Schedule is empty after applying filters. Cannot generate PDF.'}), 400
            
            # Prepare schedule data for PDF generation
            full_schedule_data = {
                'schedule': schedule,
                'preferences': preferences,
                'schedule_name': schedule_name,
                'schedule_type': preferences.get('schedule_type', 'Custom'),
                'subjects': list(set([session.get('subject') for session in schedule if session.get('subject')])),
                'statistics': _calculate_schedule_statistics(schedule) if include_statistics else {},
                'export_options': {
                    'color_theme': color_theme,
                    'include_statistics': include_statistics,
                    'date_range': date_range,
                    'subjects_filter': subjects_filter
                }
            }
            
            # Generate PDF
            pdf_generator = SchedulePDFGenerator()
            pdf_bytes = pdf_generator.generate_schedule_pdf(
                user_name=user.get('firstname', 'Student'),
                schedule_data=full_schedule_data
            )
            
            if not pdf_bytes:
                logger.error(f"Failed to generate PDF for user {user_id}")
                return jsonify({'error': 'Failed to generate PDF'}), 500
            
            logger.info(f"PDF generated successfully for user {user_id}")
            
            # Send email if requested
            email_sent = False
            if send_email:
                email_sent = notification_manager.send_schedule_pdf_email(
                    user_id=user_id,
                    schedule_data=full_schedule_data,
                    pdf_bytes=pdf_bytes,
                    send_type='export'
                )
            
            # Log the export
            log_user_action(user_id, "schedule_pdf_export", {
                "schedule_id": str(schedule_doc['_id']),
                "session_count": len(schedule),
                "email_sent": email_sent,
                "customizations": {
                    "color_theme": color_theme,
                    "include_statistics": include_statistics,
                    "subjects_filter": len(subjects_filter) > 0
                }
            })
            
            if send_email:
                if email_sent:
                    logger.info(f"Schedule PDF export email sent successfully to user {user_id}")
                    return jsonify({
                        'status': 'success',
                        'message': 'Schedule PDF exported and sent via email successfully',
                        'pdf_generated': True,
                        'pdf_sent': True,
                        'session_count': len(schedule),
                        'total_hours': full_schedule_data['statistics'].get('total_hours', 0)
                    })
                else:
                    logger.error(f"Failed to send schedule PDF export email to user {user_id}")
                    return jsonify({
                        'status': 'partial_success',
                        'message': 'PDF generated successfully but failed to send via email',
                        'pdf_generated': True,
                        'pdf_sent': False
                    }), 500
            else:
                # Return PDF as download
                response = make_response(pdf_bytes)
                response.headers['Content-Type'] = 'application/pdf'
                response.headers['Content-Disposition'] = f'attachment; filename="schedule_{user_id}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.pdf"'
                return response
                
        except Exception as e:
            logger.error(f"Error exporting schedule PDF: {str(e)}")
            return jsonify({'error': 'Error exporting schedule PDF'}), 500

    @app.route('/schedule/<user_id>/export-all', methods=['POST'])
    def export_schedule_all_formats(user_id):
        """Export user schedule in all supported formats"""
        try:
            data = request.json or {}
            send_email = data.get('send_email', False)
            formats = data.get('formats', ['json', 'csv', 'ical', 'pdf'])  # Default to all formats
            
            # Validate user exists
            try:
                user_object_id = ObjectId(user_id) if isinstance(user_id, str) else user_id
                user = users_collection.find_one({"_id": user_object_id})
                if not user:
                    return jsonify({'error': 'User not found'}), 404
            except:
                return jsonify({'error': 'Invalid user ID format'}), 400
            
            # Get the user's schedule
            query = {'userId': {'$in': [user_id, user_object_id]}, 'is_active': True}
            schedule_doc = schedules_collection.find_one(query)
            
            if not schedule_doc:
                return jsonify({'error': 'No active schedule found for this user'}), 404
            
            export_results = {}
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # JSON Export
            if 'json' in formats:
                try:
                    export_data = {
                        'export_info': {
                            'exported_by': 'EduMaster',
                            'export_date': datetime.now().isoformat(),
                            'user_name': f"{user.get('firstname', '')} {user.get('lastname', '')}".strip(),
                            'format_version': '1.0'
                        },
                        'schedule_data': {
                            'schedule_id': str(schedule_doc['_id']),
                            'schedule_name': schedule_doc.get('schedule_name', 'Default Schedule'),
                            'schedule': schedule_doc.get('schedule', []),
                            'preferences': schedule_doc.get('preferences', {}),
                            'statistics': _calculate_schedule_statistics(schedule_doc.get('schedule', []))
                        }
                    }
                    export_results['json'] = {
                        'success': True,
                        'filename': f"schedule_{user_id}_{timestamp}.json",
                        'size': len(json.dumps(export_data))
                    }
                except Exception as e:
                    export_results['json'] = {'success': False, 'error': str(e)}
            
            # CSV Export
            if 'csv' in formats:
                try:
                    csv_content = _generate_csv_content(schedule_doc)
                    export_results['csv'] = {
                        'success': True,
                        'filename': f"schedule_{user_id}_{timestamp}.csv",
                        'size': len(csv_content)
                    }
                except Exception as e:
                    export_results['csv'] = {'success': False, 'error': str(e)}
            
            # iCal Export
            if 'ical' in formats:
                try:
                    user_name = f"{user.get('firstname', '')} {user.get('lastname', '')}".strip()
                    ical_content = _generate_ical_content(schedule_doc, user_name)
                    export_results['ical'] = {
                        'success': True,
                        'filename': f"schedule_{user_id}_{timestamp}.ics",
                        'size': len(ical_content)
                    }
                except Exception as e:
                    export_results['ical'] = {'success': False, 'error': str(e)}
            
            # PDF Export
            if 'pdf' in formats:
                try:
                    full_schedule_data = {
                        'schedule': schedule_doc.get('schedule', []),
                        'preferences': schedule_doc.get('preferences', {}),
                        'schedule_name': schedule_doc.get('schedule_name', 'Default Schedule'),
                        'schedule_type': schedule_doc.get('preferences', {}).get('schedule_type', 'Custom'),
                        'subjects': list(set([session.get('subject') for session in schedule_doc.get('schedule', []) if session.get('subject')])),
                        'statistics': _calculate_schedule_statistics(schedule_doc.get('schedule', []))
                    }
                    
                    pdf_generator = SchedulePDFGenerator()
                    pdf_bytes = pdf_generator.generate_schedule_pdf(
                        user_name=user.get('firstname', 'Student'),
                        schedule_data=full_schedule_data
                    )
                    
                    if pdf_bytes:
                        export_results['pdf'] = {
                            'success': True,
                            'filename': f"schedule_{user_id}_{timestamp}.pdf",
                            'size': len(pdf_bytes)
                        }
                        
                        # Send email if requested
                        if send_email:
                            email_sent = notification_manager.send_schedule_pdf_email(
                                user_id=user_id,
                                schedule_data=full_schedule_data,
                                pdf_bytes=pdf_bytes,
                                send_type='export'
                            )
                            export_results['pdf']['email_sent'] = email_sent
                    else:
                        export_results['pdf'] = {'success': False, 'error': 'Failed to generate PDF'}
                except Exception as e:
                    export_results['pdf'] = {'success': False, 'error': str(e)}
            
            # Log the batch export
            successful_exports = [fmt for fmt, result in export_results.items() if result.get('success')]
            log_user_action(user_id, "schedule_batch_export", {
                "schedule_id": str(schedule_doc['_id']),
                "formats": successful_exports,
                "session_count": len(schedule_doc.get('schedule', []))
            })
            
            logger.info(f"Batch schedule export completed for user {user_id}. Successful formats: {successful_exports}")
            
            return jsonify({
                'status': 'success',
                'message': f'Schedule export completed. {len(successful_exports)} out of {len(formats)} formats exported successfully.',
                'export_results': export_results,
                'successful_formats': successful_exports,
                'timestamp': timestamp
            })
            
        except Exception as e:
            logger.error(f"Error in batch schedule export: {str(e)}")
            return jsonify({'error': 'Error in batch schedule export'}), 500

    @app.route('/schedule/<user_id>/test-pdf', methods=['POST'])
    def test_schedule_pdf(user_id):
        """Test PDF generation and email sending with a sample schedule"""
        try:
            # Validate user exists
            try:
                user_object_id = ObjectId(user_id) if isinstance(user_id, str) else user_id
                user = users_collection.find_one({"_id": user_object_id})
                if not user:
                    return jsonify({'error': 'User not found'}), 404
            except:
                return jsonify({'error': 'Invalid user ID format'}), 400
            
            # Create a sample schedule for testing
            sample_schedule = [
                {
                    'id': 'test_1',
                    'day': 'monday',
                    'time': '09:00-11:00',
                    'subject': 'Mathematics',
                    'type': 'study',
                    'location': 'Study Room A',
                    'notes': 'Focus on calculus derivatives'
                },
                {
                    'id': 'test_2',
                    'day': 'monday',
                    'time': '14:00-16:00',
                    'subject': 'Computer Science',
                    'type': 'study',
                    'location': 'Library',
                    'notes': 'Data structures and algorithms'
                },
                {
                    'id': 'test_3',
                    'day': 'tuesday',
                    'time': '10:00-12:00',
                    'subject': 'Physics',
                    'type': 'study',
                    'location': 'Lab',
                    'notes': 'Quantum mechanics review'
                }
            ]
            
            sample_preferences = {
                'schedule_type': 'Test',
                'focus_duration': 120,
                'break_duration': 15,
                'preferred_study_time': 'mixed'
            }
            
            # Prepare test schedule data
            full_schedule_data = {
                'schedule': sample_schedule,
                'preferences': sample_preferences,
                'schedule_name': 'Test Schedule - PDF Generation',
                'schedule_type': 'Test Schedule',
                'subjects': list(set([session.get('subject') for session in sample_schedule if session.get('subject')])),
                'statistics': _calculate_schedule_statistics(sample_schedule)
            }
            
            # Generate PDF
            pdf_generator = SchedulePDFGenerator()
            pdf_bytes = pdf_generator.generate_schedule_pdf(
                user_name=user.get('firstname', 'Student'),
                schedule_data=full_schedule_data
            )
            
            if not pdf_bytes:
                logger.error(f"Failed to generate test PDF for user {user_id}")
                return jsonify({'error': 'Failed to generate test PDF'}), 500
            
            logger.info(f"Test PDF generated successfully for user {user_id}")
            
            # Send email with PDF attachment
            email_sent = notification_manager.send_schedule_pdf_email(
                user_id=user_id,
                schedule_data=full_schedule_data,
                pdf_bytes=pdf_bytes,
                send_type='test'
            )
            
            log_user_action(user_id, "schedule_pdf_test", {
                "session_count": len(sample_schedule),
                "test_type": "pdf_generation_and_email"
            })
            
            return jsonify({
                'status': 'success',
                'message': 'Test schedule PDF generated and processed successfully',
                'pdf_generated': True,
                'pdf_sent': email_sent,
                'test_data': {
                    'session_count': len(sample_schedule),
                    'total_hours': full_schedule_data['statistics']['total_hours'],
                    'subjects': full_schedule_data['subjects'],
                    'user_email': user.get('email', 'Not found'),
                    'statistics': full_schedule_data['statistics']
                }
            })
                
        except Exception as e:
            logger.error(f"Error in test schedule PDF generation: {str(e)}")
            return jsonify({'error': f'Error in test schedule PDF generation: {str(e)}'}), 500

    logger.info("Schedule export routes registered successfully")
